###### Bibliotecas
import pandas as pd
import numpy as np
from hurst import compute_Hc, random_walk
import yfinance
from plotly.subplots import make_subplots
import plotly.graph_objects as go
import kaleido
from sklearn.naive_bayes import GaussianNB
from sklearn.naive_bayes import BernoulliNB
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
from sklearn.metrics import classification_report, confusion_matrix
import sklearn.metrics as metrics
import talib
import warnings
import matplotlib.pyplot as plt
import math
from scipy.stats import norm

warnings.filterwarnings("ignore")
pd.set_option('display.max_rows', None)
pd.set_option('display.max_columns', None)

stocks = ['NTCO3.SA']
'''
['PETR4.SA', 'HBOR3.SA', 'AGRO3.SA', 'CIEL3.SA', 'CMIG4.SA', 'BOVA11.SA',
        'PETR4.SA', 'LIGT3.SA', 'MTRE3.SA', 'KLBN11.SA', 'BPAN4.SA', 'RDOR3.SA','SUZB3.SA',
        'EZTC3.SA', 'GOLL4.SA', 'ELET3.SA', 'EQTL3.SA', 'EGIE3.SA', 'QUAL3.SA', 'ENEV3.SA',
        'CSAN3.SA', 'VIVT3.SA', 'VBBR3.SA', 'BPAC11.SA', 'LREN3.SA', 'WEGE3.SA','CMIG3.SA',
        'HYPE3.SA', 'BBDC4.SA', 'BBDC3.SA', 'CYRE3.SA','AZUL4.SA', 'BHIA3.SA', 'STBP3.SA',
        'VALE3.SA', 'FLRY3.SA', 'CVCB3.SA','MEAL3.SA', 'ECOR3.SA', 'BBSE3.SA',
        'COGN3.SA', 'AMAR3.SA', 'ELET6.SA','PSSA3.SA', 'B3SA3.SA', 'HAPV3.SA',
        'PETZ3.SA','YDUQ3.SA', 'MULT3.SA', 'CRFB3.SA', 'RENT3.SA', 'CCRO3.SA', 'IRBR3.SA',
        'ITSA3.SA', 'TAEE11.SA', 'BBAS3.SA', 'ABEV3.SA', 'NTCO3.SA', 'ITUB3.SA', 'ARZZ3.SA',
        'EMBR3.SA', 'JBSS3.SA', 'GGBR4.SA', 'UGPA3.SA', 'RADL3.SA', 'SBSP3.SA', 'RAIL3.SA', 'PRIO3.SA',
        'AAPL', 'XOM','GE','IBM','MSFT', 'GOOGL', 'AMZN','GLD', 'SLV', 'USO', 'UNG', 'DBA','EURUSD=X', 'GBPUSD=X',
        'USDJPY=X','USDBRL=X', 'USDEUR=X', 'USDJPY=X','BRL=X','^BVSP','HASH11.SA']
'''
'''Looping lógico e filtros'''
for symbol in stocks:
    # Parametros e dataset
    start = "2019-01-01"
    # “1m”, “2m”, “5m”, “15m”, “30m”, “60m”, “90m”, “1h”, “1d”, “5d”, “1wk”, “1mo”, “3mo”
    df0 = yfinance.download(symbol, start, interval = '1d')
    df0["Returns"] = df0["Adj Close"].pct_change(1)
    
    df0["Adj"] = df0["Adj Close"]
    df0["Adj Open"] = df0["Open"]
    df0["Adj High"] = df0["High"]
    df0["Adj Low"] = df0["Low"]
    
    # DEFINIÇÃO DE INTERVALO DE TREINO E TESTE
    start_train = "2019-01-01"
    end_train = "2022-12-31"
    start_val = "2023-01-01"
    end_val = "2024-06-04"
    
    # EXPOENTE DE HURST
    hurst = lambda x: compute_Hc(x)[0]
    df0["hurst100"] = df0["Adj Close"].rolling(100).apply(hurst)
    df0["hurst150"] = df0["Adj Close"].rolling(150).apply(hurst)
    df0["hurst200"] = df0["Adj Close"].rolling(200).apply(hurst)
    
    # INDICADORES TÉCNICOS
    k = 10
    df0["SMA5"] = df0["Adj Close"].rolling(5).mean()
    df0["SMA10"] = df0["Adj Close"].rolling(10).mean()
    df0["SMA20"] = df0["Adj Close"].rolling(20).mean()
    df0["SMA50"] = df0["Adj Close"].rolling(50).mean()
    df0["SMA100"] = df0["Adj Close"].rolling(100).mean()
    
    df0["EMA5"] = talib.EMA(df0["Adj Close"], timeperiod = 5)
    df0["EMA10"] = talib.EMA(df0["Adj Close"], timeperiod = 10)
    df0["EMA20"] = talib.EMA(df0["Adj Close"], timeperiod = 20)
    df0["EMA50"] = talib.EMA(df0["Adj Close"], timeperiod = 50)
    df0["EMA100"] = talib.EMA(df0["Adj Close"], timeperiod = 100)
    
    df0["upperband"], df0["middleband"], df0["lowerband"] = talib.BBANDS(df0["Adj Close"], timeperiod = 20, nbdevup = 2, nbdevdn = 2, matype = 0)
    df0["bandwidth"] = df0["upperband"]-df0["lowerband"]
    df0["perc_b"] = (df0["Adj Close"]-df0["lowerband"])/df0["bandwidth"]
    
    df0["RSI5"] = talib.RSI(df0["Adj Close"], timeperiod = 5)
    df0["RSI9"] = talib.RSI(df0["Adj Close"], timeperiod = 9)
    df0["RSI20"] = talib.RSI(df0["Adj Close"], timeperiod = 20)
    
    df0["RSI5_lag"] = df0["RSI5"].shift(k)
    df0["RSI9_lag"] = df0["RSI9"].shift(k)
    df0["RSI20_lag"] = df0["RSI20"].shift(k)
    
    df0["MACD"], df0["macdsignal"], df0["macdhist"] = talib.MACD(df0["Adj Close"], fastperiod = 12, slowperiod = 26, signalperiod = 9)
    
    df0["slowk"], df0["slowd"] = talib.STOCH(df0["Adj High"], df0["Adj Low"], df0["Adj Close"], fastk_period = 5, slowk_period = 3, slowk_matype = 0
                                              , slowd_period = 3, slowd_matype = 0)
    
    df0["fastk"], df0["fastd"] = talib.STOCHF(df0["Adj High"], df0["Adj Low"], df0["Adj Close"], fastk_period = 5, fastd_period = 3, fastd_matype = 0)
    df0["William"] = talib.WILLR(df0["Adj High"], df0["Adj Low"], df0["Adj Close"], timeperiod = 14)
    
    df0["ADX"] = talib.ADX(df0["Adj High"], df0["Adj Low"] , df0["Adj Close"], timeperiod = 14)
    df0["PLUS_DI"] = talib.PLUS_DI(df0["Adj High"], df0["Adj Low"] , df0["Adj Close"], timeperiod = 14)
    df0["MINUS_DI"] = talib.MINUS_DI(df0["Adj High"], df0["Adj Low"] , df0["Adj Close"], timeperiod = 14)
    
    #Price and MACD Golden Cross and Dead Cross (2) # Vars 5-6
    df0["var1"] = np.where(((df0["macdhist"] > 0) & (df0["Returns"] > 0)),1 ,0)
    df0["var6"] = np.where(((df0["macdhist"] < 0) & (df0["Returns"] > 0)),1 ,0)
    
    #Price and Bollinger Band > 80 or <20 (2) # Vars 7-8
    df0["var7"] = np.where(((df0["perc_b"] > 0.8) & (df0["Returns"] > 0)),1 ,0)
    df0["var8"] = np.where(((df0["perc_b"] < 0.2) & (df0["Returns"] > 0)),1 ,0)
    
    # SMA Golden Cross and Dead Cross with volume of trading (60) # Vars 9-30
    df0["var9"] = np.where((df0["SMA5"] > df0["SMA10"]),1 ,0)
    df0["var10"] = np.where((df0["SMA5"] < df0["SMA10"]),1 ,0)
    df0["var11"] = np.where((df0["SMA5"] > df0["SMA20"]),1 ,0)
    df0["var12"] = np.where((df0["SMA5"] < df0["SMA20"]),1 ,0)
    df0["var13"] = np.where((df0["SMA5"] > df0["SMA50"]),1 ,0)
    df0["var14"] = np.where((df0["SMA5"] < df0["SMA50"]),1 ,0)
    df0["var15"] = np.where((df0["SMA5"] > df0["SMA100"]),1 ,0)
    df0["var16"] = np.where((df0["SMA5"] < df0["SMA100"]),1 ,0)
    
    df0["var17"] = np.where((df0["SMA10"] > df0["SMA20"]),1 ,0)
    df0["var18"] = np.where((df0["SMA10"] < df0["SMA20"]),1 ,0)
    df0["var19"] = np.where((df0["SMA10"] > df0["SMA50"]),1 ,0)
    df0["var20"] = np.where((df0["SMA10"] < df0["SMA50"]),1 ,0)
    df0["var21"] = np.where((df0["SMA10"] > df0["SMA100"]),1 ,0)
    df0["var22"] = np.where((df0["SMA10"] < df0["SMA100"]),1 ,0)
    
    df0["var23"] = np.where((df0["SMA20"] > df0["SMA50"]),1 ,0)
    df0["var24"] = np.where((df0["SMA20"] < df0["SMA50"]),1 ,0)
    df0["var25"] = np.where((df0["SMA20"] > df0["SMA100"]),1 ,0)
    df0["var26"] = np.where((df0["SMA20"] < df0["SMA100"]),1 ,0)
                            
    df0["var29"] = np.where((df0["SMA50"] > df0["SMA100"]),1 ,0)
    df0["var30"] = np.where((df0["SMA50"] < df0["SMA100"]),1 ,0)
    
    # EMA Golden Cross and Dead Cross with volume of trading (60) # Vars 31-50
    df0["var31"] = np.where((df0["EMA5"] > df0["EMA10"]),1 ,0)
    df0["var32"] = np.where((df0["EMA5"] < df0["EMA10"]),1 ,0)
    df0["var33"] = np.where((df0["EMA5"] > df0["EMA20"]),1 ,0)
    df0["var34"] = np.where((df0["EMA5"] < df0["EMA20"]),1 ,0)
    df0["var35"] = np.where((df0["EMA5"] > df0["EMA50"]),1 ,0)
    df0["var36"] = np.where((df0["EMA5"] < df0["EMA50"]),1 ,0)
    df0["var37"] = np.where((df0["EMA5"] > df0["EMA100"]),1 ,0)
    df0["var38"] = np.where((df0["EMA5"] < df0["EMA100"]),1 ,0)
    
    df0["var39"] = np.where((df0["EMA10"] > df0["EMA20"]),1 ,0)
    df0["var40"] = np.where((df0["EMA10"] < df0["EMA20"]),1 ,0)
    df0["var41"] = np.where((df0["EMA10"] > df0["EMA50"]),1 ,0)
    df0["var42"] = np.where((df0["EMA10"] < df0["EMA50"]),1 ,0)
    df0["var43"] = np.where((df0["EMA10"] > df0["EMA100"]),1 ,0)
    df0["var44"] = np.where((df0["EMA10"] < df0["EMA100"]),1 ,0)
    
    df0["var45"] = np.where((df0["EMA20"] > df0["EMA50"]),1 ,0)
    df0["var46"] = np.where((df0["EMA20"] < df0["EMA50"]),1 ,0)
    df0["var47"] = np.where((df0["EMA20"] > df0["EMA100"]),1 ,0)
    df0["var48"] = np.where((df0["EMA20"] < df0["EMA100"]),1 ,0)

    
    df0["var49"] = np.where((df0["EMA50"] > df0["EMA100"]),1 ,0)
    df0["var50"] = np.where((df0["EMA50"] < df0["EMA100"]),1 ,0)
    
    # RSI >70 or < 30 (2) # Vars 53-58
    df0["var53"] = np.where( df0["RSI5"] > 55,1 ,0)
    df0["var54"] = np.where( df0["RSI5"] < 45,1 ,0)
    
    df0["var55"] = np.where( df0["RSI9"] > 55,1 ,0)
    df0["var56"] = np.where( df0["RSI9"] < 45,1 ,0)
    
    df0["var57"] = np.where( df0["RSI20"] > 55,1 ,0)
    df0["var58"] = np.where( df0["RSI20"] < 45,1 ,0)
    
    # RSI Golden Cross and Dead Cross (6) # Vars 59-64
    df0["var59"] = np.where(((df0["RSI5"] > df0["RSI9"])),1 ,0)
    df0["var60"] = np.where(((df0["RSI5"] < df0["RSI9"])),1 ,0)
    df0["var61"] = np.where(((df0["RSI5"] > df0["RSI20"])),1 ,0)
    df0["var62"] = np.where(((df0["RSI5"] < df0["RSI20"])),1 ,0)
    
    df0["var63"] = np.where(((df0["RSI9"] > df0["RSI20"])),1 ,0)
    df0["var64"] = np.where(((df0["RSI9"] < df0["RSI20"])),1 ,0)
    
    # Divergence of RSI and Price (6) # Vars 65-70
    df0["var65"] = np.where(((df0["RSI5"] > df0["RSI5_lag"]) & (df0["Returns"] > 0)),1 ,0)
    df0["var66"] = np.where(((df0["RSI5"] < df0["RSI5_lag"]) & (df0["Returns"] > 0)),1 ,0)
    
    df0["var67"] = np.where(((df0["RSI9"] > df0["RSI9_lag"]) & (df0["Returns"] > 0)),1 ,0)
    df0["var68"] = np.where(((df0["RSI9"] < df0["RSI9_lag"]) & (df0["Returns"] > 0)),1 ,0)
    
    df0["var69"] = np.where(((df0["RSI20"] > df0["RSI20_lag"]) & (df0["Returns"] > 0)),1 ,0)
    df0["var70"] = np.where(((df0["RSI20"] < df0["RSI20_lag"]) & (df0["Returns"] > 0)),1 ,0)
    
    # Stochastic Slow (K% D%)/Fast (K% D%)(4) # Vars 71-74
    df0["var71"] = np.where((df0["slowk"]/df0["fastk"]) > 1, 1, 0)
    df0["var72"] = np.where((df0["slowk"]/df0["fastd"]) > 1, 1, 0)
    df0["var73"] = np.where((df0["slowd"]/df0["fastk"]) > 1, 1, 0)
    df0["var74"] = np.where((df0["slowd"]/df0["fastd"]) > 1, 1, 0)
    
    # William % R > 80 or < 20 (2) # Vars 75-76
    df0["var75"] = np.where( df0["William"] > -20,1 ,0)
    df0["var76"] = np.where( df0["William"] < -80,1 ,0)
    
    # DI and ADX (4) # Vars 77-78
    df0["var77"] = np.where(((df0["PLUS_DI"] > df0["ADX"])),1 ,0)
    df0["var78"] = np.where(((df0["MINUS_DI"] > df0["ADX"])),1 ,0)
    
    # DI+ DI- # Vars 80
    df0["var80"] = np.where(((df0["PLUS_DI"] > df0["MINUS_DI"])),1 ,0)
    
    # Hurst # Vars 81-83
    df0["var81"] = np.where(((df0["hurst100"] > 0.5)),1 ,0)
    df0["var82"] = np.where(((df0["hurst150"] > 0.5)),1 ,0)
    df0["var83"] = np.where(((df0["hurst200"] > 0.5)),1 ,0)
    
    df0 = df0.dropna(axis = 0) 
    
    # CALCULO ALVO
    df0["Alvo_Bin"] = np.where(df0["SMA10"].shift(-k)>df0["SMA50"].shift(-k), 1, 0)
    df0["Alvo"] = (df0["Adj Close"].shift(-k)/df0["Adj Close"]-1)*100
    
    pd.pivot_table(df0, index = ["Alvo_Bin"], aggfunc = {"Adj Close" : len, "Alvo" : np.mean})
    pd.pivot_table(df0, index = ["var83"], aggfunc = {"Adj Close" : len, "Alvo" : np.mean})
    
    # TREINAMENTO E TESTE
    df0_dev = df0.loc[start_train : end_train]
    df0_val = df0.loc[start_val : end_val]
    
    X = df0_dev.iloc[:, df0_dev.columns.get_loc("var1"):df0_dev.columns.get_loc("var83")+1]
    y = df0_dev["Alvo_Bin"]
    
    X_val = df0_val.iloc[:, df0_val.columns.get_loc("var1"):df0_val.columns.get_loc("var83")+1]
    y_val = df0_val["Alvo_Bin"]
    
    X_train, X_test, y_train, y_test = train_test_split(X , y, test_size = 0.70, random_state = 42)
    
    model1 = GaussianNB(var_smoothing = 0.01)
    model2 = BernoulliNB(fit_prior = False, alpha = 0.01)
    
    # TREINO
    model1.fit(X_train, y_train)
    model2.fit(X_train, y_train)
    
    # Fit na base de treinamento
    fit_train1 = model1.predict(X_train)
    fit_train2 = model2.predict(X_train)
    
    # Fit na base de teste
    fit_test1 = model1.predict(X_test)
    fit_test2 = model2.predict(X_test)
    
    # Fit prob na base de teste
    prob_test1 = model1.predict_proba(X_test)
    prob_test2 = model2.predict_proba(X_test)
    
    # Fit na base de validação
    fit_val1 = model1.predict(X_val)
    fit_val2 = model2.predict(X_val)
    
    # Fit prob na base de validação
    prob_val1 = model1.predict_proba(X_val)
    prob_val2 = model2.predict_proba(X_val)
    
    # Avaliação dos Retornos
    df_avaliacao = df0_val[["Adj Close", "Alvo", "Alvo_Bin", "var9", "SMA5", "SMA10", "SMA20","SMA50", "RSI9", "RSI20", "hurst100", "hurst150", "hurst200"]]
    df_avaliacao["Modelo1"] = fit_val1
    df_avaliacao["Modelo2"] = fit_val2
    
    # CUSTO DA OPERAÇÃO
    custo = 0.05
    
    # CRIR COLUNA COM RETORNO DESCONTANDO CUSTO
    df_avaliacao["Ret_Modelo1"] = np.where(((df_avaliacao["Modelo1"] == 1) & (df_avaliacao["Adj Close"] > df_avaliacao["SMA10"])), df0_val["Alvo"]-custo, np.where(((df_avaliacao["Modelo1"] == 0) & (df_avaliacao["Adj Close"] < df_avaliacao["SMA10"])), -df0_val["Alvo"]-custo,0))
    df_avaliacao["Ret_Modelo2"] = np.where(((df_avaliacao["Modelo2"] == 1) & (df_avaliacao["Adj Close"] > df_avaliacao["SMA10"])), df0_val["Alvo"]-custo, np.where(((df_avaliacao["Modelo2"] == 0) & (df_avaliacao["Adj Close"] < df_avaliacao["SMA10"])), -df0_val["Alvo"]-custo,0))
    
    # SOMAR OS RETORNOS E ADICIONAR EM UMA COLUNA
    df_avaliacao["Acc_Modelo1"] = df_avaliacao["Ret_Modelo1"].cumsum(axis = 0)
    df_avaliacao["Acc_Modelo2"] = df_avaliacao["Ret_Modelo2"].cumsum(axis = 0)
    
    # PLOTS
    #if df_avaliacao['Modelo1'].iloc[-1] != df_avaliacao['Modelo1'].iloc[-3]:
    # PLOT HURST
    fig = make_subplots(rows = 2, cols = 1, shared_xaxes = True, vertical_spacing = 0.05)
    fig.add_trace(go.Scatter(x = df0.index, y = df0["Adj Close"], name = symbol, line = dict(color = "black")), row = 1, col = 1)
    fig.add_trace(go.Scatter(x = df0.index, y = df0["hurst100"], name = "Hurst 100", line = dict(color = "blue")), row = 2, col = 1)
    fig.add_trace(go.Scatter(x = df0.index, y = df0["hurst150"], name = "Hurst 150", line = dict(color = "purple")), row = 2, col = 1)
    fig.add_trace(go.Scatter(x = df0.index, y = df0["hurst200"], name = "Hurst 200", line = dict(color = "red")), row = 2, col = 1)
    fig.add_hline(y = 0.5, line_width = 2, line_dash = "dash", line_color = "black", row = 2, col = 1)
    fig.update_layout(height = 600, width = 800
                      , title_text = "Hurst Exponent " + symbol + " - OMNP"
                      , font_color = "blue"
                      , title_font_color = "black"
                      , xaxis2_title = "2020 - 2022"
                      , yaxis_title = "Close"
                      , yaxis2_title = "Hurst"
                      , showlegend = True
                      , legend_title = "Hurst"
                      , font = dict(size = 15, color = "Black"))
    fig.show()
    
    # PLOT RESULTADOS
    fig = make_subplots(rows = 3, cols = 1, shared_xaxes = True, vertical_spacing = 0.05)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.round(df_avaliacao["Adj Close"].shift(-1), 2), name = "Close", line = dict(color = "gray")), row = 1, col = 1)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.where(df_avaliacao["Modelo1"] == 1, df_avaliacao["Adj Close"].shift(-1), None), name = "Buy", line = dict(color = "blue")), row = 1, col = 1)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.where(df_avaliacao["Modelo1"] == 0, df_avaliacao["Adj Close"].shift(-1), None), name = "Sell", line = dict(color = "red")), row = 1, col = 1)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.round(df_avaliacao["Modelo1"], 2), name = "Modelo1", line = dict(color = "black")), row = 2, col = 1)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.round(df_avaliacao["Acc_Modelo1"], 2), name = "Gaussian", line = dict(color = "blue")), row = 3, col = 1)
    fig.add_trace(go.Scatter(x = df_avaliacao.index, y = np.round(df_avaliacao["Acc_Modelo2"], 2), name = "Bernoulli", line = dict(color = "red")), row = 3, col = 1)
    fig.update_layout(height=800, 
                        width=800, 
                        title_text="Validação Naive Bayes " + symbol, 
                        font_color="blue", 
                        title_font_color="black",
                        xaxis3_title="Year", 
                        yaxis_title="Close", 
                        yaxis2_title="Outcome", 
                        yaxis3_title="Accumulated Return (%)",
                        showlegend=True, 
                        legend_title="Modelo", 
                        font=dict(size=15, color="Black"))
    fig.show()
    
    mascara_compra = df_avaliacao['Modelo1'] == 1
    mascara_venda = df_avaliacao['Modelo1'] == 0
    valores_compra_modelo1 = df_avaliacao.loc[mascara_compra, 'Ret_Modelo1']
    valores_venda_modelo1 = df_avaliacao.loc[mascara_venda, 'Ret_Modelo1']
    compra_plot = valores_compra_modelo1.cumsum(axis = 0)
    venda_plot = valores_venda_modelo1.cumsum(axis = 0)
    
    # PLOT RESULTADOS buy/sell
    fig = make_subplots(rows = 1, cols = 1, shared_xaxes = True, vertical_spacing = 0.05)
    fig.add_trace(go.Scatter(x = compra_plot.index, y = np.round(compra_plot, 2), name = "Long", line = dict(color = "blue")), row = 1, col = 1)
    fig.add_trace(go.Scatter(x = compra_plot.index, y = np.round(venda_plot, 2), name = "Short", line = dict(color = "red")), row = 1, col = 1)
    fig.update_layout(height=500, 
                        width=800, 
                        title_text="       ", 
                        font_color="blue", 
                        title_font_color="black",
                        yaxis_title="Return", 
                        showlegend=True,
                        legend_title="Trades", 
                        font=dict(size=15, color="Black"))
    fig.show()

# Definindo as colunas desejadas
colunas_desejadas = ['Adj Close', 'Modelo1', 'Modelo2']
df_filtrado = df_avaliacao[colunas_desejadas].copy()

# Função para adicionar 1 para o décimo terceiro dia do mês e 0 para os outros dias
def adicionar_dia_rolagem(data):
    return 1 if data.day == 13 else 0

# Preço da put no exercício
def prec_exerc_put(df_filtrado):
    df_filtrado['Exerc_Put'] = None
    for i in range(len(df_filtrado)):
        if df_filtrado.iloc[i]['Put'] == 1:
            for j in range(i + 1, len(df_filtrado)):
                if df_filtrado.iloc[j]['dia_rolagem'] == 1:
                    df_filtrado.at[df_filtrado.index[i], 'Exerc_Put'] = df_filtrado.iloc[j]['Adj Close']
                    break
    df_filtrado['Var_Put'] = df_filtrado.apply(lambda row: row['Exerc_Put'] - (row['Strike']) if pd.notnull(row['Exerc_Put']) else None, axis=1)

# Preço da call no exercício
def prec_exerc_call(df_filtrado):
    df_filtrado['Exerc_Call'] = None
    for i in range(len(df_filtrado)):
        if df_filtrado.iloc[i]['Call'] == 1:
            for j in range(i + 1, len(df_filtrado)):
                if df_filtrado.iloc[j]['dia_rolagem'] == 1:
                    df_filtrado.at[df_filtrado.index[i], 'Exerc_Call'] = df_filtrado.iloc[j]['Adj Close']
                    break
    df_filtrado['Var_Call'] = df_filtrado.apply(lambda row: (row['Strike']) - row['Exerc_Call'] if pd.notnull(row['Exerc_Call']) else None, axis=1)

# Adicionar colunas onde as calls e puts serão negociadas
def adicionar_primeiro_valor_1(df_filtrado):
    df_filtrado['Call'] = ((df_filtrado['Modelo1'] == 1) & (df_filtrado['Modelo1'].shift(1) != 1)).astype(int)
    df_filtrado['Put'] = ((df_filtrado['Modelo1'] == 0) & (df_filtrado['Modelo1'].shift(1) != 0)).astype(int)
    return df_filtrado

# Calcular prêmio da call
def calcular_premio_call(S, K, T, r, sigma):
    T = T / 252
    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)
    call_price = S * norm.cdf(d1) - K * math.exp(-r * T) * norm.cdf(d2)
    return call_price

# Calcular prêmio da put
def calcular_premio_put(S, K, T, r, sigma):
    T = T / 252
    d1 = (math.log(S / K) + (r + 0.5 * sigma ** 2) * T) / (sigma * math.sqrt(T))
    d2 = d1 - sigma * math.sqrt(T)
    put_price = K * math.exp(-r * T) * norm.cdf(-d2) - S * norm.cdf(-d1)
    return put_price

# Definir variáveis para calcular o prêmio inicial
def calcular_premio(row, df_filtrado):
    if row['Call'] == 1:
        S = row['Adj Close']
        K = row['Strike']
        linha_atual = df_filtrado.index.get_loc(row.name)
        proximas_linhas = df_filtrado.iloc[linha_atual + 1:]
        T = None
        for i, prox_row in proximas_linhas.iterrows():
            if prox_row['dia_rolagem'] == 1:
                T = len(pd.date_range(start=row.name, end=prox_row.name, freq='B')) - 1
                if T >= 30:
                    break 
        if T is not None:
            r = 0.105
            sigma = 0.20
            df_filtrado.at[row.name, 'DU'] = T
            return calcular_premio_call(S, K, T, r, sigma)
 
    elif row['Put'] == 1:
        S = row['Adj Close']
        K = row['Strike']
        linha_atual = df_filtrado.index.get_loc(row.name)
        proximas_linhas = df_filtrado.iloc[linha_atual + 1:]
        T = None
        for i, prox_row in proximas_linhas.iterrows():
            if prox_row['dia_rolagem'] == 1:
                T = len(pd.date_range(start=row.name, end=prox_row.name, freq='B')) - 1
                if T >= 30:
                    break
        if T is not None:
            r = 0.105
            sigma = 0.20
            df_filtrado.at[row.name, 'DU'] = T
            return calcular_premio_put(S, K, T, r, sigma)
    return None

# Definir variáveis para calcular o prêmio rolagem
def calcular_premio_rolagem(row, df_filtrado):
    coluna_premio_rolagem = 'Premio_Rolagem'
    if row['Call'] == 1:
        S = row['Adj Close']
        K = row['Strike']
        linha_atual = df_filtrado.index.get_loc(row.name)
        proximas_linhas = df_filtrado.iloc[linha_atual + 1:]
        T = None
        for i, prox_row in proximas_linhas.iterrows():
            if prox_row['dia_rolagem'] == 1:
                T = len(pd.date_range(start=row.name, end=prox_row.name, freq='B')) - 1
                if T >= 60:
                    break
        if T is not None:
            r = 0.105
            sigma = 0.30
            df_filtrado.at[row.name, 'DU'] = T
            return calcular_premio_call(S, K, T, r, sigma)
    elif row['Put'] == 1:
        S = row['Adj Close']
        K = row['Strike']
        linha_atual = df_filtrado.index.get_loc(row.name)
        proximas_linhas = df_filtrado.iloc[linha_atual + 1:]
        T = None
        for i, prox_row in proximas_linhas.iterrows():
            if prox_row['dia_rolagem'] == 1:
                T = len(pd.date_range(start=row.name, end=prox_row.name, freq='B')) - 1
                if T >= 60:
                    break
        if T is not None:
            r = 0.105
            sigma = 0.30
            df_filtrado.at[row.name, 'DU'] = T
            return calcular_premio_put(S, K, T, r, sigma)
    return None
    
# Atualizar prêmio, se call não for nan e teve uma variação negativa, adicionar como 'Rolagem'
def atualizar_premio(row):
    if pd.notna(row['Var_Call']) and row['Var_Call'] < 0:
        return 'Rolagem'
    if pd.notna(row['Var_Put']) and row['Var_Put'] < 0:
        return 'Rolagem'
    return row['Premio']

# Recalcular prêmio de rolagem e adicionar na coluna 'Premio_Rolagem'
def recalcular_premio_rolagem(df_filtrado):
    df_filtrado['Premio_Rolagem'] = None # Cria a nova coluna
    for i in range(len(df_filtrado)):
        if df_filtrado.iloc[i]['Premio'] == 'Rolagem':
            for j in range(i + 1, len(df_filtrado)):
                if df_filtrado.iloc[j]['dia_rolagem'] == 1:
                    novo_premio = calcular_premio_rolagem(df_filtrado.iloc[i], df_filtrado)
                    if novo_premio is not None:
                        novo_premio = novo_premio - (novo_premio * 0.20)
                        df_filtrado.at[df_filtrado.index[i], 'Premio_Rolagem'] = novo_premio
                    break
    return df_filtrado

# Aplicando a função para criar a nova coluna
df_filtrado['dia_rolagem'] = df_filtrado.index.map(adicionar_dia_rolagem)
df_filtrado = adicionar_primeiro_valor_1(df_filtrado)

# Criação da coluna com valor do strike (Variável K do Black-Scholes)
#df_filtrado['Strike'] = df_filtrado['Adj Close'] + (df_filtrado['Call'] == 1).astype(int) - (df_filtrado['Put'] == 1).astype(int)

df_filtrado['Strike'] = df_filtrado['Adj Close'] + 1 * (df_filtrado['Call'] == 1).astype(int) - 1 * (df_filtrado['Put'] == 1).astype(int)

prec_exerc_call(df_filtrado)
prec_exerc_put(df_filtrado)

df_filtrado['DU'] = None
df_filtrado['Premio'] = df_filtrado.apply(lambda row: calcular_premio(row, df_filtrado), axis=1)

df_filtrado['Premio'] = df_filtrado['Premio'].fillna(0)

# Aplicando a função ao DataFrame
df_filtrado['Premio'] = df_filtrado.apply(atualizar_premio, axis=1)
df_filtrado = recalcular_premio_rolagem(df_filtrado)
df_filtrado = df_filtrado.round(2)

display(df_filtrado)

# Convertendo os valores da coluna 'A' para numéricos (os que não forem serão NaN)
df_filtrado['Premio'] = pd.to_numeric(df_filtrado['Premio'], errors='coerce')

# Somando os valores da coluna 'A', ignorando os NaNs
soma_coluna_A = df_filtrado['Premio'].sum()
print(f'Premios recebidos sem considerar rolagens: {soma_coluna_A}')
print(' ')

soma = df_filtrado['Premio_Rolagem'].sum()
print(f'Premio das rolagens: {soma}')
print(' ')

"""
ADICIONAR COLUNA COM O PREÇO DO STRIKE
SE DU < 10: PULAR O VENCIMENTO VIGENTE
"""
